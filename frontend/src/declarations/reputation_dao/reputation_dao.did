type UserDecayInfo = 
 record {
   lastActivityTime: nat;
   lastDecayTime: nat;
   registrationTime: nat;
   totalDecayed: nat;
 };
type UserCompliance = 
 record {
   kycVerified: bool;
   tags: vec text;
 };
type UserBadges = vec Badge;
type TransactionType = 
 variant {
   Award;
   Decay;
   Revoke;
 };
type Transaction = 
 record {
   amount: nat;
   from: principal;
   id: nat;
   reason: opt text;
   timestamp: nat;
   to: principal;
   transactionType: TransactionType;
 };
type TopUp = 
 record {
   amount: nat;
   from: opt principal;
   id: nat;
   timestamp: nat;
 };
type TierRule = 
 record {
   maxPoints: opt nat;
   minPoints: nat;
   tier: Tier;
 };
type TierPayout = 
 record {
   btcAmount: nat;
   ethAmount: nat;
   icpAmount: nat;
   tier: Tier;
 };
type Tier = 
 variant {
   Bronze;
   Custom: text;
   Gold;
   Silver;
 };
type SpendControl = 
 record {
   railDailyCaps: record {
                    btc: opt nat;
                    eth: opt nat;
                    icp: opt nat;
                  };
   usdCapE8s: opt nat;
 };
type ScheduledPayoutConfig = 
 record {
   enabled: bool;
   frequency: PayoutFrequency;
   maxBtcPerCycle: nat;
   maxEthPerCycle: nat;
   maxIcpPerCycle: nat;
   tiers: vec TierPayout;
 };
type ReputationChild = 
 service {
   acceptOwnership: () -> (text);
   addTrustedAwarder: (p: principal, name: text) -> (text);
   awardRep: (to: principal, amount: nat, reason: opt text) -> (text);
   awarderStats: (awardee: principal) -> (vec AwarderBreakdown) query;
   blacklist: (user: principal, on: bool) -> (text);
   blacklistWithReason: (user: principal, on: bool, reason: opt text) ->
    (text);
   configureAutoAwarder: (enable: bool) -> (text);
   configureDecay: (decayRate: nat, decayInterval: nat, minThreshold: 
    nat, gracePeriod: nat, enabled: bool) -> (text);
   cycles_balance: () -> (nat) query;
   emitEvent: (kind: text, payload: blob) -> (text);
   findTransactionsByReason: (substr: text, limit: nat) ->
    (vec Transaction) query;
   getBalance: (p: principal) -> (nat) query;
   getBalanceWithDetails: (p: principal) ->
    (record {
       currentBalance: nat;
       decayInfo: opt UserDecayInfo;
       pendingDecay: nat;
       rawBalance: nat;
     }) query;
   getBlacklistEntry: (user: principal) ->
    (opt record {
           active: bool;
           reason: opt text;
           updatedAt: nat;
         }) query;
   getDecayConfig: () -> (DecayConfig) query;
   getDecayStatistics: () ->
    (record {
       configEnabled: bool;
       lastGlobalDecayProcess: nat;
       totalDecayedPoints: nat;
     }) query;
   getEventsPaged: (offset: nat, limit: nat) -> (vec Event) query;
   getTierRules: () -> (vec TierRule) query;
   getTopUpCount: () -> (nat) query;
   getTopUpsPaged: (offset: nat, limit: nat) -> (vec TopUp) query;
   getTransactionById: (id: nat) -> (opt Transaction) query;
   getTransactionCount: () -> (nat) query;
   getTransactionHistory: () -> (vec Transaction) query;
   getTransactionsByUser: (user: principal) -> (vec Transaction) query;
   getTransactionsPaged: (offset: nat, limit: nat) -> (vec Transaction) query;
   getTreasuryLink: () -> (opt principal) query;
   getTreasuryStats: () ->
    (record {
       events: nat;
       failures: nat;
       treasury: opt principal;
     }) query;
   getTrustedAwarders: () -> (vec Awarder) query;
   getUserDecayInfo: (p: principal) -> (opt UserDecayInfo) query;
   getUserTier: (user: principal) -> (Tier) query;
   getUsersByTier: () -> (vec record {
                                principal;
                                Tier;
                              }) query;
   getUsersByTierPaged: (offset: nat, limit: nat) ->
    (vec record {
           principal;
           Tier;
         }) query;
   health: () ->
    (record {
       cycles: nat;
       decayConfigHash: nat;
       paused: bool;
       topUpCount: nat;
       txCount: nat;
       users: nat;
     }) query;
   leaderboard: (top: nat, offset: nat) ->
    (vec record {
           principal;
           nat;
         }) query;
   multiAward: (pairs: vec record {
                             principal;
                             nat;
                             opt text;
                           }, atomic: bool) -> (text);
   myStats: (user: principal) ->
    (record {
       balance: nat;
       lastActivity: nat;
       lifetimeAwarded: nat;
       lifetimeRevoked: nat;
       totalDecayed: nat;
     }) query;
   nominateOwner: (candidate: principal) -> (text);
   notifyTreasuryDeposit: (rail: Rail, amount: nat, memo: opt text) -> (text);
   orgPulse: (since: nat) ->
    (record {
       awards: nat;
       decays: nat;
       revokes: nat;
     }) query;
   pause: (p: bool) -> (text);
   previewDecayAmount: (p: principal) -> (nat) query;
   processBatchDecay: () -> (text);
   removeTrustedAwarder: (p: principal) -> (text);
   resetUser: (user: principal, reason: opt text) -> (text);
   /// Drain (almost) all cycles to the factory's wallet_receive.
   /// Only callable by the factory or the owner.
   /// Returns the number of cycles successfully transferred.
   returnCyclesToFactory: (minRemain: nat) -> (nat);
   revokeRep: (from: principal, amount: nat, reason: opt text) -> (text);
   runTreasuryPayoutCycle: () -> (text);
   setDailyMintLimit: (limit: nat) -> (text);
   setDecayBatchSize: (size: nat) -> (text);
   setMinCyclesAlert: (threshold: nat) -> (text);
   setParent: (canisterId: principal) -> (text);
   setPerAwarderDailyLimit: (awardee: principal, limit: nat) -> (text);
   setTierRules: (rules: vec TierRule) -> (text);
   setTreasuryBadges: (user: principal, badges: UserBadges) -> (text);
   setTreasuryCompliance: (user: principal, info: UserCompliance) -> (text);
   setTreasuryLink: (target: opt principal) -> (text);
   setTreasuryRails: (rails: RailsEnabled) -> (text);
   snapshotHash: () -> (nat) query;
   syncTreasuryConfig: (cfg: OrgConfig) -> (text);
   topUp: () -> (nat);
   transferOwnership: (newOwner: principal) -> (text);
   triggerManualDecay: () -> (text);
   version: () -> (text) query;
   wallet_receive: () -> (nat);
   withdrawCycles: (to: principal, amount: nat) -> (text);
 };
type RailsEnabled = 
 record {
   btc: bool;
   eth: bool;
   icp: bool;
 };
type RailThresholds = 
 record {
   btcMin: nat;
   ethMin: nat;
   icpMin: nat;
 };
type Rail = 
 variant {
   BTC;
   ETH;
   ICP;
 };
type PayoutFrequency = 
 variant {
   CustomDays: nat;
   Monthly;
   Weekly;
 };
type OrgConfig = 
 record {
   compliance: ComplianceRule;
   deadman: DeadManConfig;
   microTips: MicroTipConfig;
   rails: RailsEnabled;
   scheduled: ScheduledPayoutConfig;
   spendControl: opt SpendControl;
   thresholds: RailThresholds;
 };
type MicroTipConfig = 
 record {
   btcTipAmount: nat;
   enabled: bool;
   ethTipAmount: nat;
   icpTipAmount: nat;
   maxBtcPerPeriod: nat;
   maxEthPerPeriod: nat;
   maxEventsPerWindow: nat;
   maxIcpPerPeriod: nat;
 };
type Event = 
 record {
   id: nat;
   kind: text;
   payload: blob;
   timestamp: nat;
 };
type DecayConfig = 
 record {
   decayInterval: nat;
   decayRate: nat;
   enabled: bool;
   gracePeriod: nat;
   minThreshold: nat;
 };
type DeadManConfig = 
 record {
   enabled: bool;
   inactivityThresholdSeconds: nat;
 };
type ComplianceRule = 
 record {
   kycRequired: bool;
   tagWhitelist: vec text;
 };
type Badge = 
 record {
   name: text;
   rail: opt Rail;
 };
type AwarderBreakdown = 
 record {
   awarder: principal;
   lastAward: nat;
   total: nat;
 };
type Awarder = 
 record {
   id: principal;
   name: text;
 };
service : (initOwner: principal, initFactory: principal) -> ReputationChild
